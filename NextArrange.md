## 题目

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> 1,2,3 → 1,3,2
> 3,2,1 → 1,2,3
> 1,1,5 → 1,5,1

## 思路

用i,j两个指针从后往前找第一个后面比前面大的数，然后交换这两个数，但还要交换i之后的数。

字典序：

> 在[数学](https://baike.baidu.com/item/数学/107037)中，字典或词典顺序（也称为词汇顺序，字典顺序，字母顺序或词典顺序）是基于字母顺序排列的单词按字母顺序排列的方法。 这种泛化主要在于定义有序完全有序集合（通常称为字母表）的元素的序列（通常称为计算机科学中的单词）的总顺序。
>
> 对于数字1、2、3......n的排列，不同排列的先后关系是从左到右逐个比较对应的数字的先后来决定的。例如对于5个数字的排列 12354和12345，排列12345在前，排列12354在后。按照这样的规定，5个数字的所有的排列中最前面的是12345，最后面的是  54321。

## 代码

```c
void swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}
void nextPermutation(int* nums, int numsSize){
    if(numsSize == 0)
        return;
    int i, j;
    for(i = numsSize - 2; i >= 0 && nums[i+1] <= nums[i]; i--);
    if(i >= 0){
      
        for(j = numsSize - 1; j >= 0 && nums[j] <= nums[i]; j--);
      
        swap(&nums[i], &nums[j]);
    }
   
    for(j = 0; j <= (numsSize - 2 - i) / 2; j++){
        swap(&nums[i+1+j], &nums[numsSize-1-j]);
    }
}

```

